##' @title The function hdmax2::estimate_effect() takes as input an object 
##' hdmax2_step1 and a list of potential mediators MS to be analyzed in subsequent steps.
##' @description  For each univariate exposure variable and the subset of mediators MS,
##' the hdmax2::estimate_effect() function computes several estimates
##' to evaluate the indirect effects in the path between exposure variables
##' and the survival variable. Initially, this function assesses each mediator
##' variable MS_j individually and computes causal measures of interest
##' such as (i) the Average Causal Mediated Effect (ACME, corresponding to
##' the indirect effect) and (ii) the Proportion Mediated (PM). The ACME
##' differs from the Average Direct Effect (ADE), which represents the
##' unmediated effect, and from the Total Effect (TE) which is equal to the sum
##' of direct and indirect effect. PM corresponds to the proportion of
##' the total effect that is mediated by the mediator (ratio of the indirect
##' effect to the total effect). ACME and PM are computed by the
##'  mediation::mediate() function of the package mediation, that
##' automatically detects the type of statistical model used in the mediation
##' analysis (Tingley et al. 2014). The function mediation::mediate()
##' calculates uncertainty estimates by a quasi-Bayesian Monte Carlo approach
##' described (Imai et al. 2010). In addition, it estimates the intermediary
##' effect sizes  a_j and b_j and their standard deviations. Eventually,
##' hdmax2 calculates an Overall Indirect Effect (OIE) from a single model
##' that includes all mediators MS simultaneously. The OIE corresponds
##' to the sum of the indirect effect associated with all mediators.
##' The confidence interval (CI) of the OIE is estimated by a bootstrap
##' approach. Along with the OIE, hdmax2 estimates the Overall Total
##' Effect (OTE) corresponding to the effect of exposure variables on
##' the outcome variable, as well as the Overall Direct Effect (ODE)
##' corresponding to the effect of exposure variables on the outcome variable
##' when the mediators MS are included in the model.
##'
##' @param object results from hdmax2 step 2
##' @param m a response variable matrix with n rows and p columns corresponding to mediators selected at step1.
##' Response variables must be encoded as numeric. No NAs allowed.
##' @param boots number of bootstrap
##' @param ... arguments for inner functions
##' @return hdmax2_step2_surv_param object
##' 
##'  - ACME, estimation of the average causal mediation effect (the indirect effect)
##'  - ADE, estimation average direct effect
##'  - PM, estimation of the proportion mediated
##'  - TE, estimation of the total effect
##'  
##' Regressions:
##'  - xm, regression X on M
##'  - my, regression M on Y
##' 
##' 
##' Overall effect
##'  - oie, overall indirect effect
##'  - oie_med , oie median
##'  - oie_sd , oie standard deviation
##'  - ote, overall total effect
##'  - ode, overall direct effect
##'  
##' @details
##'
##' We use the mediate function of the mediation package on the set of markers having Q-value lower
##' than the FDR threshold. It estimates their indirect effects and 
##' tests their significance.
##'
##' @export
##' @author Florence Pittion, Magali Richard, Olivier Francois, Basile Jumentier
##' @examples 
##' # Load example dataset
##' attach(simu_data)
##' K = 5
##' # Run {hdmax2} step 1
##' hdmax2_step1 = hdmax2::run_AS(
##'   exposure = simu_data$X_binary,
##'   outcome =  simu_data$Y_continuous,
##'   M =  simu_data$M1,
##'   K = K
##' )
##' # Select mediators
##' mediators_subset = names(sort(hdmax2_step1$max2_pvalues)[1:10])
##' mediators_top10 = simu_data$M1[, mediators_subset]
##' # Run {hdmax2} step 2
##' hdmax2_step2 = hdmax2::estimate_effect(object = hdmax2_step1, 
##'                                        m = mediators_top10)

estimate_effect_surv_param <- function(object , m, boots = 1000, ...) {
  
  if (class(object)!="hdmax2_step1_surv_param"){
    stop("The object is not of class hdmax2_step1. This function only compute hdmax2 objects generated by hdmax2::run_AS")
  }
  
  exposure_mat = object$input$exposure_input
  survival_time = object$input$survival_time
  censoring_status = object$input$censoring_status_input
  #survival_distribution = object$input$survival_distribution 
  base = survival::Surv(survival_time, censoring_status)
  M = m
  
  distributions = c("weibull", "exponential", "gaussian", "logistic","lognormal", "loglogistic")
  aic_values = numeric(length(distributions))
  
  
  if (!is.matrix(M)){
    stop("m must be a matrix")
  }
  if (is.null(colnames(M))) {
    colnames(M) <- 1:ncol(M)
  }
  
  expo_var_ids =object$input$expo_var_ids
  ncol_var = length(expo_var_ids)
  
  effects = list()
  # TODO x = as.dataframe de exposure
  
  for(expo_var_id in expo_var_ids){
    if (is.vector(exposure_mat)){
      exposure = exposure_mat
    } else if (is.data.frame(exposure_mat)|| is.matrix(exposure_mat)){
      exposure = exposure_mat[, expo_var_id]
    }
    
    if( ncol_var == 1){
      message("Estimating indirect effect for univariate exposome.")  
      
      if (is.null(object$input$covar)) {
        covars = data.frame(latent_factors = object$AS_1$U)
      } else  {
        covars = data.frame(obs_covar = object$input$covar, latent_factors = object$AS_1$U)
      } 
      if (is.null(object$input$covar_sup_reg2)) {
        covars_2 = data.frame(latent_factors = object$AS_1$U)
      } else  {
        covars_2 = data.frame(obs_covar = object$input$covar, obs_covar_2 = object$input$covar_sup_reg2, latent_factors = object$AS_1$U)
      } 
    } else if( ncol_var > 1) {
      message("Estimating indirect effect for multivariate exposome.") 
      extra_expo_vars = expo_var_ids[-which(expo_var_ids %in% expo_var_id)]
      df_extra = exposure_mat[,which(expo_var_ids %in% extra_expo_vars)]
      if(is.vector(df_extra)){
        df_extra = t(t(df_extra))
      }
      for(col in 1:dim(df_extra)[2]){
        if(typeof(df_extra[,col])=="character"){
          df_extra[,col] = as.factor(df_extra[,col])
          message(paste("Categorial column " , col , " transformed in factors in covariable data frame"))
        } else if (is.factor(df_extra[,col])) {
          message(paste("Categorial column " , col , " is factors in covariable data frame"))
        } else if (typeof(df_extra[,col])=="integer"||typeof(df_extra[,col])== "logical"||typeof(df_extra[,col])== "double"){
          df_extra[,col] = as.numeric(df_extra[,col])
          message(paste("Column " , col , " is Continuous or Binary in covariable data frame"))
        }
      }
      if (is.null(object$input$covar)) {
        covars = data.frame(latent_factors = object$AS_1$U, df_extra = df_extra)
      } else  {
        covars = data.frame(obs_covar = object$input$covar, latent_factors = object$AS_1$U, df_extra = df_extra)
      } 
      if (is.null(object$input$covar_sup_reg2)) {
        covars_2 = data.frame(latent_factors = object$AS_1$U, df_extra = df_extra)
      } else  {
        covars_2 = data.frame(obs_covar = object$input$covar, obs_covar_2 = object$input$covar_sup_reg2, latent_factors = object$AS_1$U, df_extra = df_extra)
      }
    }
    
    expo_var_type =  typeof(exposure)
    if (expo_var_type == "character"||is.factor(exposure)){
      message("The input exposome is categorial")
      if(is.factor(exposure)==FALSE){
        exposure_fact = as.factor(exposure)
      } else {
        exposure_fact = exposure
      }
      exposure_dm = stats::model.matrix(~exposure_fact)
      message("categorial exposome design matrix transformation")
      exposure = exposure_dm[,-1]
      cn = colnames(exposure)
      
      
      k_effects = list()
      
      for (k in 1:length(cn)) {
        
        # from package mediation
        ACME <- matrix(ncol = 4, nrow = ncol(M))
        ADE <- matrix(ncol = 4, nrow = ncol(M))
        PM <- matrix(ncol = 4, nrow = ncol(M))
        TE <- matrix(ncol = 4, nrow = ncol(M))
        
        # from linear models
        xm <- matrix(ncol = 4, nrow = ncol(M))
        my <- matrix(ncol = 4, nrow = ncol(M))
        
        for (i in 1:ncol(M)) {#numeric
          
          dat.x <- data.frame(exposure_k = exposure[,k], exposure_minus_k = exposure[,-k], Mi = M[, i], covars = covars)
          dat.y <- data.frame(exposure_k = exposure[,k], exposure_minus_k = exposure[,-k], Mi = M[, i], survival_time = survival_time, censoring_status = censoring_status, covars = covars_2)
          
          mod1 = stats::lm(Mi ~ exposure_k + ., data = dat.x)
          message(paste0("Generate regression 1 for categorial exposure and mediator ", i))
          
          for (d in seq_along(distributions)) {
            # Ajuster le modèle avec la distribution courante
            fit = survival::survreg(survival::Surv(survival_time, censoring_status) ~ exposure_k + Mi + ., data = dat.y, dist = distributions[d])
            
            # Calculer l'AIC pour ce modèle
            aic_values[d] = -2 * as.numeric(logLik(fit)) + 2 * length(coef(fit))
          }
          
          names(aic_values) = distributions
          best_distribution = names(which.min(aic_values))
   
          mod2 <- survival::survreg(survival::Surv(survival_time, censoring_status) ~ exposure_k + Mi + ., data = dat.y, dist = best_distribution)
          message(paste0("Generate regression 2 for survival outcome and mediator ", i))
 
          xm[i, ] <- summary(mod1)$coeff[2, ] # effect of X
          my[i, ] <- summary(mod2)$table[3,] # effect of M
          
          
          #### on est supposer preciser l'outcome selon doc de mediation car objet survreg ne le fait , à verifier
          
          med = mediation::mediate(mod1, mod2, treat = "exposure_k", mediator = "Mi")
          
          ACME[i, ] <- c(med$d0, med$d0.ci[1], med$d0.ci[2], med$d0.p)
          ADE[i, ] <- c(med$z0, med$z0.ci[1], med$z0.ci[2], med$z0.p)
          PM[i, ] <- c(med$n0, med$n0.ci[1], med$n0.ci[2], med$n0.p)
          TE[i, ] <- c(med$tau.coef, med$tau.ci[1], med$tau.ci[2], med$tau.p)
        }
        
        ACME <- as.data.frame(ACME)
        ADE <- as.data.frame(ADE)
        PM <- as.data.frame(PM)
        TE <- as.data.frame(TE)
        xm <- as.data.frame(xm)
        my <- as.data.frame(my)
        
        colnames(ACME) <- c("est", "CI_2.5", "CI_97.5", "pval")
        colnames(ADE) <- c("est", "CI_2.5", "CI_97.5", "pval")
        colnames(PM) <- c("est", "CI_2.5", "CI_97.5", "pval")
        colnames(TE) <- c("est", "CI_2.5", "CI_97.5", "pval")
        colnames(xm) <- c("Estimate", "Std.Error", "t.Value", "pValue")
        colnames(my) <- c("Estimate", "Std.Error", "z.Value", "pValue")
        
        ACME$feat <- colnames(M)
        ADE$feat <- colnames(M)
        PM$feat <- colnames(M)
        TE$feat <- colnames(M)
        xm$feat <- colnames(M)
        my$feat <- colnames(M)
        
        # bootstrap
        acme_sum <- matrix(nrow = 1, ncol = boots)
        #covars = as.matrix(covars)
        
        for (i in 1:ncol(acme_sum)) {
          
          if (is.data.frame(exposure)||is.matrix(exposure)){
            samp <- sample(dim(exposure)[1], replace = T)
          } else if (is.vector(exposure)) {
            samp <- sample(length(exposure[,k]), replace = T)
          }
          
          data_samp <- data.frame(exposure_k = exposure[samp,k], exposure_minus_k = exposure[samp,-k], covars = covars[samp, ])
          # effect A X -> M
          mod1 <- stats::lm(M[samp,] ~ exposure_k + ., data = data_samp)
          A <- t(sapply(summary(mod1), function(x) x$coeff[2, ]))
          A <- data.frame(feat = rownames(A), A)
          
          # effect B m -> Y
          
          data_b <- data.frame(exposure_k = exposure[samp,k], exposure_minus_k = exposure[samp,-k] , M=M[samp,] , covars = covars_2[samp,])
          for (d in seq_along(distributions)) {
            # Ajuster le modèle avec la distribution courante
            fit = survival::survreg(base ~ ., data = data_b, dist = distributions[d])
            # Calculer l'AIC pour ce modèle
            aic_values[d] = -2 * as.numeric(logLik(fit)) + 2 * length(coef(fit))
          }
          names(aic_values) = distributions
          best_distribution = names(which.min(aic_values))
          mod2 = survival::survreg(base ~ ., data = data_b, dist = best_distribution)
          B = as.data.frame(summary(mod2)$table)[3:(ncol(M)+2),]
          
          colnames(B) <- c("B", "B_sd", "B_zv", "B_pv")
          colnames(A)[2:5] <- c("A", "A_sd", "A_tv", "A_pv")
          
          ab <- cbind(A, B)
          rownames(ab) <- NULL
          
          # effect A*B
          ab$AB <- ab$A * ab$B
          acme_sum[i] <- sum(ab$AB)
        }
        
        ### Compute ODE and OTE for the survival model

        data_total = data.frame(exposure =exposure, base= base, covars = covars_2)
        data_b <- data.frame(exposure_k = exposure[samp,k], exposure_minus_k = exposure[samp,-k] , M=M[samp,] , covars = covars_2[samp,])
        for (d in seq_along(distributions)) {
          # Ajuster le modèle avec la distribution courante
          fit = survival::survreg(base ~ . , data =  data_total, dist = distributions[d])
                                  
                                  # Calculer l'AIC pour ce modèle
                                  aic_values[d] = -2 * as.numeric(logLik(fit)) + 2 * length(coef(fit))
                                  }
        names(aic_values) = distributions
        best_distribution = names(which.min(aic_values))
        mod_total_effect = survival::survreg(base ~ . , data =  data_total, dist = best_distribution)
        
        data_direct = data.frame(exposure =exposure, base= base, M =M ,covars = covars_2)
        for (d in seq_along(distributions)) {
          # Ajuster le modèle avec la distribution courante
          fit = survival::survreg(base ~ ., data =  data_direct, dist = distributions[d])
          
          # Calculer l'AIC pour ce modèle
          aic_values[d] = -2 * as.numeric(logLik(fit)) + 2 * length(coef(fit))
        }
        names(aic_values) = distributions
        best_distribution = names(which.min(aic_values))
        mod_direct_effect = survival::survreg(base ~ ., data =  data_direct, dist = best_distribution)
 
        ote = summary(mod_total_effect)$table[2,]
        ode = summary(mod_direct_effect)$table[2,]
        
        oie = as.vector(acme_sum)
        oie_med = median(as.vector(acme_sum))
        oie_sd = sd(as.vector(acme_sum))
        
        tmp = list(ACME=ACME, ADE=ADE, PM=PM, TE=TE, xm=xm, my=my, oie=oie, oie_med=oie_med, oie_sd=oie_sd, ote=ote, ode=ode)
      
        k_effects[[paste0("cat_", k)]] = tmp
        
      }
      
      effects[[expo_var_id]] = k_effects
      
      
    } else if (expo_var_type== "integer"||expo_var_type== "logical"||expo_var_type== "double"){
      message("The input exposome is continuous or binary" )
      # boolean transformed as numeric
      exposure = as.numeric(exposure)
      
      # To collect data from package mediation
      ACME <- matrix(ncol = 4, nrow = ncol(M))
      ADE <- matrix(ncol = 4, nrow = ncol(M))
      PM <- matrix(ncol = 4, nrow = ncol(M))
      TE <- matrix(ncol = 4, nrow = ncol(M))
      
      # To collect data from linear models
      xm <- matrix(ncol = 4, nrow = ncol(M))
      my <- matrix(ncol = 4, nrow = ncol(M))
      
      
      for (i in 1:ncol(M)) {#numeric
        dat.x <- data.frame(exposure = exposure, Mi = M[, i], covars = covars)
        dat.y <- data.frame(exposure = exposure, Mi = M[, i], survival_time = survival_time, censoring_status = censoring_status, covars = covars_2)
        mod1 = stats::lm(Mi ~ exposure + ., data = dat.x)
        message(paste0("Generate regression 1 for continuous or binary exposure and mediator ", i))
        
        
          for (d in seq_along(distributions)) {
          # Ajuster le modèle avec la distribution courante
          fit = survival::survreg(survival::Surv(survival_time, censoring_status) ~ exposure + Mi + ., data = dat.y, dist = distributions[d])
          
          # Calculer l'AIC pour ce modèle
          aic_values[d] = -2 * as.numeric(logLik(fit)) + 2 * length(coef(fit))
        }
        
        names(aic_values) = distributions
        best_distribution = names(which.min(aic_values))
        
        mod2 <- survival::survreg(survival::Surv(survival_time, censoring_status) ~ exposure + Mi + ., data = dat.y, dist = best_distribution)
        message(paste0("Generate regression 2 for survival outcome and mediator ", i))

        xm[i, ] <- summary(mod1)$coeff[2, ] # effect of X
        my[i, ] <- summary(mod2)$table[3,] # effect of M
   
        med = mediation::mediate(mod1, mod2, treat = "exposure", mediator = "Mi")#,boot = TRUE, outcome = "survival_time")
        
        ACME[i, ] <- c(med$d0, med$d0.ci[1], med$d0.ci[2], med$d0.p)
        ADE[i, ] <- c(med$z0, med$z0.ci[1], med$z0.ci[2], med$z0.p)
        PM[i, ] <- c(med$n0, med$n0.ci[1], med$n0.ci[2], med$n0.p)
        TE[i, ] <- c(med$tau.coef, med$tau.ci[1], med$tau.ci[2], med$tau.p)
      } 
      
      ACME <- as.data.frame(ACME)
      ADE <- as.data.frame(ADE)
      PM <- as.data.frame(PM)
      TE <- as.data.frame(TE)
      xm <- as.data.frame(xm)
      my <- as.data.frame(my)
      
      colnames(ACME) <- c("est", "CI_2.5", "CI_97.5", "pval")
      colnames(ADE) <- c("est", "CI_2.5", "CI_97.5", "pval")
      colnames(PM) <- c("est", "CI_2.5", "CI_97.5", "pval")
      colnames(TE) <- c("est", "CI_2.5", "CI_97.5", "pval")
      colnames(xm) <- c("Estimate", "Std.Error", "t.Value", "pValue")
      colnames(my) <- c("Estimate", "Std.Error", "z.Value", "pValue")
     
      ACME$feat <- colnames(M)
      ADE$feat <- colnames(M)
      PM$feat <- colnames(M)
      TE$feat <- colnames(M)
      xm$feat <- colnames(M)
      my$feat <- colnames(M)
    
      ### Compute OIE by bootstrap
      
      # bootstrap
      acme_sum <- matrix(nrow = 1, ncol = boots)
      
      for (i in 1:ncol(acme_sum)) {
        
        if (is.data.frame(exposure)||is.matrix(exposure)){
          samp <- sample(dim(exposure)[1], replace = T)
        } else if (is.vector(exposure)) {
          samp <- sample(length(exposure), replace = T)
        }
        data_a <- data.frame(exposure = exposure, covars = covars)
        
        # effect A X -> M
        mod1 <- stats::lm(M[samp, ] ~ ., data = data_a[samp, ])
        if(dim(M)[2]>1) {
          A <- t(sapply(summary(mod1), function(x)
            x$coeff[2,]))
          A <- data.frame(feat = rownames(A), A)
        } else if (dim(M)[2] == 1) {
          A = summary(mod1)$coeff[2, ]
          #A <- data.frame(feat = names(A), A)
        }
      
        # effect B m -> Y
        
        data_b <- data.frame(exposure = exposure, M = M, covars = covars_2)
        
        
        distributions = c("weibull", "exponential", "gaussian", "logistic","lognormal", "loglogistic")
        aic_values = numeric(length(distributions))
        
        for (i in seq_along(distributions)) {
          # Ajuster le modèle avec la distribution courante
          fit = survival::survreg(base[samp] ~ ., data = data_b[samp, ], dist = distributions[i])
          
          # Calculer l'AIC pour ce modèle
          aic_values[i] = -2 * as.numeric(logLik(fit)) + 2 * length(coef(fit))
        }
        
        names(aic_values) = distributions
        best_distribution = names(which.min(aic_values))
        
        mod2 = survival::survreg(base[samp] ~ ., data = data_b[samp, ], dist = best_distribution)
        B = as.data.frame(summary(mod2)$table)[3:(ncol(M)+2),]
        
        
        if(dim(M)[2]>1) {
          colnames(B) <- c("B", "B_sd", "B_zv", "B_pv")
          colnames(A)[2:5] <- c("A", "A_sd", "A_tv", "A_pv")
        }else if (dim(M)[2] == 1) {
          B = t(B)
          colnames(B) <- c("B", "B_sd", "B_zv", "B_pv")
          A = t(A)
          colnames(A) <- c("A", "A_sd", "A_tv", "A_pv")
        }
        
        ab <- cbind(A, B)
        rownames(ab) <- NULL
        ab = as.data.frame(ab)
        
        # effect A*B
        ab$AB <- ab$A * ab$B
        acme_sum[i] <- sum(ab$AB)
      } # end of bootstrap
      
      ### Compute ODE and OTE for survival model
      
      data_total = data.frame(exposure =exposure, base= base, covars = covars_2)
      for (d in seq_along(distributions)) {
        # Ajuster le modèle avec la distribution courante
        fit = survival::survreg(base ~ . , data =  data_total, dist = distributions[d])
        
        # Calculer l'AIC pour ce modèle
        aic_values[d] = -2 * as.numeric(logLik(fit)) + 2 * length(coef(fit))
      }
      names(aic_values) = distributions
      best_distribution = names(which.min(aic_values))
      mod_total_effect = survival::survreg(base ~ . , data =  data_total, dist = best_distribution)
      data_direct = data.frame(exposure =exposure, base= base, M =M ,covars = covars_2)
      for (d in seq_along(distributions)) {
        # Ajuster le modèle avec la distribution courante
        fit = survival::survreg(base ~ . , data =  data_direct, dist = distributions[d])
        
        # Calculer l'AIC pour ce modèle
        aic_values[d] = -2 * as.numeric(logLik(fit)) + 2 * length(coef(fit))
      }
      names(aic_values) = distributions
      best_distribution = names(which.min(aic_values))
      mod_direct_effect = survival::survreg(base ~ ., data =  data_direct, dist = best_distribution)
      
      ote = summary(mod_total_effect)$table[2,]
      ode = summary(mod_direct_effect)$table[2,]
      
      oie = as.vector(acme_sum)
      oie_med = median(as.vector(acme_sum))
      oie_sd = sd(as.vector(acme_sum))
      
      tmp = list(ACME=ACME, ADE=ADE, PM=PM, TE=TE, xm=xm, my=my, oie=oie, oie_med=oie_med, oie_sd=oie_sd, ote=ote, ode=ode)
      
      effects[[expo_var_id]] = tmp
      
    }
  }
  
  obj = list(effects = effects,
             input = object$input)
  
  class(obj) = "hdmax2_step2"
  
  return(obj)
}
